#!/usr/bin/env node
/**
 * Vector SVG to 1-bit Bitmap Converter
 *
 * Rasterizes vector SVGs to bitmap, then converts to rect-based pixel art
 * for on-chain storage.
 *
 * Usage: node vector-to-1bit.js <input.svg> <output_name> [--size 128|256]
 *
 * Requires: ImageMagick 7 (magick command)
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function parseArgs() {
    const args = process.argv.slice(2);
    if (args.length < 2) {
        console.error('Usage: node vector-to-1bit.js <input.svg> <output_name> [--size 128|256]');
        process.exit(1);
    }

    const config = {
        input: args[0],
        outputName: args[1],
        size: 256
    };

    const sizeIndex = args.indexOf('--size');
    if (sizeIndex !== -1 && args[sizeIndex + 1]) {
        const size = parseInt(args[sizeIndex + 1], 10);
        if (size !== 128 && size !== 256) {
            console.error('Error: --size must be 128 or 256');
            process.exit(1);
        }
        config.size = size;
    }

    return config;
}

function rasterizeSvg(inputPath, size) {
    const tempPng = `/tmp/rasterized_${Date.now()}.png`;

    // Rasterize SVG to monochrome PNG (! forces exact dimensions)
    const cmd = `magick "${inputPath}" -resize ${size}x${size}! -background white -flatten -colorspace Gray -threshold 50% "${tempPng}"`;

    console.log(`Rasterizing to ${size}x${size}...`);
    execSync(cmd, { stdio: 'inherit' });

    return tempPng;
}

function pngToRectSvg(pngPath, size) {
    // Read PNG pixel data using ImageMagick
    const cmd = `magick "${pngPath}" -depth 8 gray:-`;
    const buffer = execSync(cmd);

    const pixels = new Uint8Array(buffer);
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${size} ${size}" shape-rendering="crispEdges">\n`;

    let opaqueCount = 0;

    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const idx = y * size + x;
            // White pixels (255) are background, black pixels (0) are foreground
            if (pixels[idx] < 128) {
                svg += `<rect x="${x}" y="${y}" width="1" height="1" fill="#000000"/>\n`;
                opaqueCount++;
            }
        }
    }

    svg += '</svg>';

    return { svg, opaqueCount };
}

function createBitmap(rectSvg, size) {
    const bytesPerRow = size / 8;
    const totalBytes = size * bytesPerRow;
    const bitmap = new Uint8Array(totalBytes);

    // Parse rect elements from SVG
    const rectRegex = /<rect x="(\d+)" y="(\d+)"/g;
    let match;
    let opaqueCount = 0;

    while ((match = rectRegex.exec(rectSvg)) !== null) {
        const x = parseInt(match[1], 10);
        const y = parseInt(match[2], 10);

        if (x < size && y < size) {
            const pixelIndex = y * size + x;
            const byteIndex = Math.floor(pixelIndex / 8);
            const bitPosition = 7 - (pixelIndex % 8);

            bitmap[byteIndex] |= (1 << bitPosition);
            opaqueCount++;
        }
    }

    return { bitmap, opaqueCount, totalBytes };
}

function bitmapToHex(bitmap) {
    return Array.from(bitmap)
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
}

function generateSolidityLibrary(name, hexBitmap, size, totalBytes, color = '000000') {
    const libName = name.charAt(0).toUpperCase() + name.slice(1) + `${size}Mono`;
    const renderFunc = size === 256 ? 'render1bit256' : 'render1bit128';

    return `// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {PixelArtRenderer} from "./PixelArtRenderer.sol";

/**
 * @title ${libName}
 * @dev On-chain pixel art storage (${size}x${size}, monochrome 1-bit)
 * @notice Generated by vector-to-1bit.js - Do not edit manually
 */
library ${libName} {
    /// @notice Foreground color (RGB)
    function getColor() internal pure returns (bytes3) {
        return hex"${color}";
    }

    /// @notice ${size}x${size} pixel bitmap, 1-bit (${totalBytes} bytes)
    function getBitmap() internal pure returns (bytes memory) {
        return hex"${hexBitmap}";
    }

    /// @notice Render as SVG string
    function getSVG() internal pure returns (string memory) {
        return PixelArtRenderer.${renderFunc}(getColor(), getBitmap());
    }
}
`;
}

function main() {
    const config = parseArgs();
    const size = config.size;

    // Verify input exists
    const inputPath = path.resolve(config.input);
    if (!fs.existsSync(inputPath)) {
        console.error(`File not found: ${inputPath}`);
        process.exit(1);
    }

    console.log(`Input: ${inputPath}`);
    console.log(`Target size: ${size}x${size}`);

    // Step 1: Rasterize SVG to PNG
    const tempPng = rasterizeSvg(inputPath, size);

    // Step 2: Convert PNG to rect-based SVG
    console.log('Converting to rect-based SVG...');
    const { svg: rectSvg, opaqueCount } = pngToRectSvg(tempPng, size);

    // Clean up temp file
    fs.unlinkSync(tempPng);

    console.log(`\nOpaque pixels: ${opaqueCount} / ${size * size} (${((opaqueCount / (size * size)) * 100).toFixed(1)}%)`);

    // Step 3: Create bitmap from rect SVG
    const { bitmap, totalBytes } = createBitmap(rectSvg, size);
    const hexBitmap = bitmapToHex(bitmap);

    console.log(`Bitmap size: ${totalBytes} bytes`);

    // Generate outputs
    const assetsDir = path.join(path.dirname(inputPath));

    // Preview SVG (rect-based)
    const previewPath = path.join(assetsDir, `${config.outputName}_${size}x${size}_1bit.svg`);
    fs.writeFileSync(previewPath, rectSvg);
    console.log(`\nPreview SVG: ${previewPath}`);

    // PNG preview (white background)
    const pngPath = path.join(assetsDir, `${config.outputName}_${size}x${size}_1bit.png`);
    const pngCmd = `magick "${previewPath}" -background white -flatten "${pngPath}"`;
    execSync(pngCmd);
    console.log(`Preview PNG: ${pngPath}`);

    // Metadata
    const metadata = {
        source: inputPath,
        size: size,
        format: '1-bit monochrome',
        opaquePixels: opaqueCount,
        totalPixels: size * size,
        bytes: totalBytes
    };
    const metadataPath = path.join(assetsDir, `${config.outputName}_${size}x${size}_metadata.json`);
    fs.writeFileSync(metadataPath, JSON.stringify(metadata, null, 2));
    console.log(`Metadata: ${metadataPath}`);

    // Solidity library
    const solidityCode = generateSolidityLibrary(config.outputName, hexBitmap, size, totalBytes);
    const solidityPath = path.join(assetsDir, `${config.outputName.charAt(0).toUpperCase() + config.outputName.slice(1)}${size}Mono.sol`);
    fs.writeFileSync(solidityPath, solidityCode);
    console.log(`Solidity: ${solidityPath}`);
}

main();
